{"id": "e2a2aa5c-87cc-4d33-ab18-9995f0094dad", "code": "# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence.\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,\n    c=1.0,\n    p=1.1,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with responsive scaling.\n    \"\"\"\n    t = tau(k, c, p)\n    \n    # Compute the residual ratio\n    ratio = r_norm / max(s_norm, eps)\n    \n    if ratio > mu:\n        # Scale step size by imbalance, cap at 2.0 for stability\n        scale = min(ratio / mu, 2.0)\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n        aux = t * scale  # Reflect update magnitude\n    elif 1.0 / ratio > mu:\n        scale = min((1.0 / ratio) / mu, 2.0)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n        aux = t * scale\n    else:\n        new_rho = rho\n        mode = \"keep\"\n        aux = abs(ratio - 1.0)  # Measure of balance\n\n    return new_rho, aux, mode\n", "language": "python", "parent_id": "6450fc87-e4dc-49d2-9eb2-0b926d1e268a", "generation": 2, "timestamp": 1770118333.8457441, "iteration_found": 8, "metrics": {"combined_score": 0.038461538461538464, "metrics": {"converged": true, "iters": 13, "combined_score": 0.038461538461538464}, "artifacts": {"status": "CONVERGED", "iterations": 13, "eval_time": "25.360s"}, "formal_certification": "Lean4_Not_Auto_Proven"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 53 lines with 42 lines", "parent_metrics": {"combined_score": 0.038461538461538464, "metrics": {"converged": true, "iters": 13, "combined_score": 0.038461538461538464}, "artifacts": {"status": "CONVERGED", "iterations": 13, "eval_time": "21.646s"}, "formal_certification": "Lean4_Not_Auto_Proven"}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.0385\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.0769 \u2192 0.0385. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Metrics: combined_score: 0.0769, metrics: {'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}, artifacts: {'status': 'CONVERGED', 'iterations': 13, 'eval_time': '27.119s'}, formal_certification: Lean4_Auto_Proven\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Change 1: Replace 36 lines with 43 lines\nChange 2: Replace 10 lines with 5 lines\n- Metrics: error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 36 lines with 45 lines\nChange 2: Replace 10 lines with 11 lines\n- Metrics: error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5000)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    # Ensure k is at least 0 to avoid division by zero\n    return c / ((max(k, 0) + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Reduced from 3.0 to be more responsive\n    c=1.0,\n    p=1.1,   # Slightly reduced to make step sizes decay slower\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with improved responsiveness.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Additional step size for division to be more aggressive\n    t_div = tau(k, c=0.8, p=1.1)  # Smaller base for division updates\n\n    # Direction logic with more nuanced conditions\n    # Calculate the ratio of residuals\n    if s_norm > eps:\n        ratio = r_norm / s_norm\n    else:\n        ratio = r_norm / eps\n    \n    if ratio > mu:\n        # More aggressive multiplication when primal residual is much larger\n        new_rho = rho * (1.0 + 1.5 * t)  # Increased factor\n        mode = \"mul\"\n        # aux reflects the degree of imbalance\n        aux = min(ratio / mu, 10.0)  # Cap at 10.0 for stability\n\n    elif 1.0 / ratio > mu:\n        # More responsive division when dual residual is much larger\n        new_rho = rho / (1.0 + 1.2 * t_div)  # Using t_div\n        mode = \"div\"\n        aux = min(mu * s_norm / max(r_norm, eps), 10.0)\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n        aux = 1.0  # Neutral auxiliary value\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 2 (Score: 0.5000)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence with slower decay for more updates.\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Slightly more aggressive threshold\n    c=1.0,\n    p=1.1,   # Make step size diminish slower for more updates\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with improved responsiveness.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Compute residual ratio for more nuanced update\n    ratio = r_norm / max(s_norm, eps)\n    \n    # Direction logic with smoother transitions\n    if ratio > mu:\n        # More aggressive update when residuals are very imbalanced\n        # Scale step size by how much ratio exceeds mu\n        scale = min(2.0, ratio / mu)\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n        aux = t * scale  # Capture update magnitude\n        \n    elif 1.0 / ratio > mu:\n        # Dual residual is much larger\n        scale = min(2.0, (1.0 / ratio) / mu)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n        aux = t * scale\n        \n    else:\n        # Residuals are balanced\n        new_rho = rho\n        mode = \"keep\"\n        # aux reflects how balanced residuals are\n        aux = abs(ratio - 1.0)\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 3 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on combined_score (0.0769), Performs well on metrics ({'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}), Performs well on artifacts ({'status': 'CONVERGED', 'iterations': 13, 'eval_time': '27.119s'}), Performs well on formal_certification (Lean4_Auto_Proven)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0385)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic with adaptive scaling based on residual ratio\n    # Compute safe ratios\n    r_ratio = r_norm / max(s_norm, eps)\n    s_ratio = s_norm / max(r_norm, eps)\n    \n    if r_ratio > mu:\n        # Scale the step size by how much the ratio exceeds mu, but cap it\n        scale = min(r_ratio / mu, 5.0)  # Cap at 5 to prevent too large steps\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n    elif s_ratio > mu:\n        scale = min(s_ratio / mu, 5.0)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to metrics\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5000, Type: Experimental)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence with slower decay for more updates.\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Slightly more aggressive threshold\n    c=1.0,\n    p=1.1,   # Make step size diminish slower for more updates\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with improved responsiveness.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Compute residual ratio for more nuanced update\n    ratio = r_norm / max(s_norm, eps)\n    \n    # Direction logic with smoother transitions\n    if ratio > mu:\n        # More aggressive update when residuals are very imbalanced\n        # Scale step size by how much ratio exceeds mu\n        scale = min(2.0, ratio / mu)\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n        aux = t * scale  # Capture update magnitude\n        \n    elif 1.0 / ratio > mu:\n        # Dual residual is much larger\n        scale = min(2.0, (1.0 / ratio) / mu)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n        aux = t * scale\n        \n    else:\n        # Residuals are balanced\n        new_rho = rho\n        mode = \"keep\"\n        # aux reflects how balanced residuals are\n        aux = abs(ratio - 1.0)\n\n    return new_rho, aux, mode\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.5000, Type: Experimental)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    # Ensure k is at least 0 to avoid division by zero\n    return c / ((max(k, 0) + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Reduced from 3.0 to be more responsive\n    c=1.0,\n    p=1.1,   # Slightly reduced to make step sizes decay slower\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with improved responsiveness.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Additional step size for division to be more aggressive\n    t_div = tau(k, c=0.8, p=1.1)  # Smaller base for division updates\n\n    # Direction logic with more nuanced conditions\n    # Calculate the ratio of residuals\n    if s_norm > eps:\n        ratio = r_norm / s_norm\n    else:\n        ratio = r_norm / eps\n    \n    if ratio > mu:\n        # More aggressive multiplication when primal residual is much larger\n        new_rho = rho * (1.0 + 1.5 * t)  # Increased factor\n        mode = \"mul\"\n        # aux reflects the degree of imbalance\n        aux = min(ratio / mu, 10.0)  # Cap at 10.0 for stability\n\n    elif 1.0 / ratio > mu:\n        # More responsive division when dual residual is much larger\n        new_rho = rho / (1.0 + 1.2 * t_div)  # Using t_div\n        mode = \"div\"\n        aux = min(mu * s_norm / max(r_norm, eps), 10.0)\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n        aux = 1.0  # Neutral auxiliary value\n\n    return new_rho, aux, mode\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0769, Type: Exploratory)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], NumPy-based implementation, Comprehensive implementation\n\n# Current Program\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic with adaptive scaling based on residual ratio\n    # Compute safe ratios\n    r_ratio = r_norm / max(s_norm, eps)\n    s_ratio = s_norm / max(r_norm, eps)\n    \n    if r_ratio > mu:\n        # Scale the step size by how much the ratio exceeds mu, but cap it\n        scale = min(r_ratio / mu, 5.0)  # Cap at 5 to prevent too large steps\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n    elif s_ratio > mu:\n        scale = min(s_ratio / mu, 5.0)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["Looking at the current program, I notice its fitness score is 0.0385, which is lower than the previous attempt (0.0769). The current program introduces adaptive scaling based on residual ratios, but this might be too aggressive or not properly balanced. The top-performing programs (with score 0.5000) use different approaches: they have a lower mu (2.5 vs 3.0), a different p (1.1 vs 1.2), and more nuanced update logic.\n\nThe current program's scaling factor is capped at 5.0, which might be too large and could cause instability. Also, the auxiliary value is just t, which doesn't capture the degree of imbalance, which might be useful for convergence.\n\nLet's analyze:\n1. The top programs use mu=2.5, which is more responsive than mu=3.0.\n2. They use p=1.1, which makes step sizes decay slower, allowing more updates over iterations.\n3. They have more sophisticated auxiliary values that reflect the update magnitude or imbalance.\n\nHowever, we need to be careful to maintain C1-safety (summable step sizes). The current program's scaling factor multiplies t, which is summable, but if scale is too large, it might violate the conditions? Actually, since t is summable and scale is bounded, the product is still summable.\n\nBut to improve fitness, let's try to incorporate elements from the top programs while keeping the code concise (under 500 characters). The current program is longer than 500 characters? Let's check.\n\nActually, the note says \"code length exceeds 500 characters\", so we should simplify. The current program has some redundancy: we compute both r_ratio and s_ratio, but we can compute just one ratio and its reciprocal.\n\nLet's simplify and improve by:\n1. Lower mu to 2.5 for more responsiveness.\n2. Use p=1.1 for slower decay.\n3. Use a single ratio and scale step size based on how much it exceeds mu, but cap at a smaller value (like 2.0, as in top programs).\n4. Make auxiliary value more informative.\n\nHere are the changes:\n\n<<<<<<< SEARCH\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic with adaptive scaling based on residual ratio\n    # Compute safe ratios\n    r_ratio = r_norm / max(s_norm, eps)\n    s_ratio = s_norm / max(r_norm, eps)\n    \n    if r_ratio > mu:\n        # Scale the step size by how much the ratio exceeds mu, but cap it\n        scale = min(r_ratio / mu, 5.0)  # Cap at 5 to prevent too large steps\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n    elif s_ratio > mu:\n        scale = min(s_ratio / mu, 5.0)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n=======\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence.\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,\n    c=1.0,\n    p=1.1,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with responsive scaling.\n    \"\"\"\n    t = tau(k, c, p)\n    \n    # Compute the residual ratio\n    ratio = r_norm / max(s_norm, eps)\n    \n    if ratio > mu:\n        # Scale step size by imbalance, cap at 2.0 for stability\n        scale = min(ratio / mu, 2.0)\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n        aux = t * scale  # Reflect update magnitude\n    elif 1.0 / ratio > mu:\n        scale = min((1.0 / ratio) / mu, 2.0)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n        aux = t * scale\n    else:\n        new_rho = rho\n        mode = \"keep\"\n        aux = abs(ratio - 1.0)  # Measure of balance\n\n    return new_rho, aux, mode\n>>>>>>> REPLACE\n\nThis change:\n1. Reduces mu from 3.0 to 2.5 for more frequent updates.\n2. Changes p from 1.2 to 1.1 for slower decay of step sizes.\n3. Simplifies the logic by using a single ratio and its reciprocal, which is more efficient and reduces code length.\n4. Caps the scale at 2.0 instead of 5.0 for more stability (as seen in top programs).\n5. Makes the auxiliary value more informative by capturing the update magnitude or balance.\n6. The code is now shorter and should be under 500 characters.\n\nThis approach is inspired by the top-performing programs while maintaining C1-safety. The auxiliary value now provides useful information about the update, which might help with convergence monitoring."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}