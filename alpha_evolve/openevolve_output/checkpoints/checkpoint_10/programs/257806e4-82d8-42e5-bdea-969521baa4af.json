{"id": "257806e4-82d8-42e5-bdea-969521baa4af", "code": "# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    # Ensure k is at least 0 to avoid division by zero\n    return c / ((max(k, 0) + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Balanced threshold\n    c=1.0,\n    p=1.1,\n    eps=1e-12,\n):\n    \"\"\"\n    Simplified C1-safe adaptive ADMM penalty update rule.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Compute safe ratio\n    ratio = r_norm / max(s_norm, eps)\n    \n    # Direction logic with single step size\n    if ratio > mu:\n        # Scale step size by how much ratio exceeds mu, but cap for stability\n        scale = min(ratio / mu, 2.0)\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n    elif 1.0 / ratio > mu:\n        scale = min((1.0 / ratio) / mu, 2.0)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n    \n    # Auxiliary scalar: purely tau_k (no residual dependence) for C1-safety\n    aux = t\n    \n    return new_rho, aux, mode\n", "language": "python", "parent_id": "6e2b215a-16bd-4319-b42c-89934393a249", "generation": 2, "timestamp": 1770118499.044991, "iteration_found": 10, "metrics": {"error": 0.0, "timeout": true}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 45 lines with 37 lines\nChange 2: Replace 3 lines with 4 lines", "parent_metrics": {"error": 0.0, "timeout": true}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.5000\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.0769 \u2192 0.5000\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### timeout\n```\nTrue\n```\n\n### timeout_duration\n```\n120\n```\n\n### failure_stage\n```\nevaluation\n```\n\n### error_type\n```\ntimeout\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Metrics: combined_score: 0.0769, metrics: {'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}, artifacts: {'status': 'CONVERGED', 'iterations': 13, 'eval_time': '27.119s'}, formal_certification: Lean4_Auto_Proven\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Change 1: Replace 36 lines with 43 lines\nChange 2: Replace 10 lines with 5 lines\n- Metrics: error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 36 lines with 45 lines\nChange 2: Replace 10 lines with 11 lines\n- Metrics: error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5000)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    # Ensure k is at least 0 to avoid division by zero\n    return c / ((max(k, 0) + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Reduced from 3.0 to be more responsive\n    c=1.0,\n    p=1.1,   # Slightly reduced to make step sizes decay slower\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with improved responsiveness.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Additional step size for division to be more aggressive\n    t_div = tau(k, c=0.8, p=1.1)  # Smaller base for division updates\n\n    # Direction logic with more nuanced conditions\n    # Calculate the ratio of residuals\n    if s_norm > eps:\n        ratio = r_norm / s_norm\n    else:\n        ratio = r_norm / eps\n    \n    if ratio > mu:\n        # More aggressive multiplication when primal residual is much larger\n        new_rho = rho * (1.0 + 1.5 * t)  # Increased factor\n        mode = \"mul\"\n        # aux reflects the degree of imbalance\n        aux = min(ratio / mu, 10.0)  # Cap at 10.0 for stability\n\n    elif 1.0 / ratio > mu:\n        # More responsive division when dual residual is much larger\n        new_rho = rho / (1.0 + 1.2 * t_div)  # Using t_div\n        mode = \"div\"\n        aux = min(mu * s_norm / max(r_norm, eps), 10.0)\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n        aux = 1.0  # Neutral auxiliary value\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 2 (Score: 0.5000)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence with slower decay for more updates.\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Slightly more aggressive threshold\n    c=1.0,\n    p=1.1,   # Make step size diminish slower for more updates\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with improved responsiveness.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Compute residual ratio for more nuanced update\n    ratio = r_norm / max(s_norm, eps)\n    \n    # Direction logic with smoother transitions\n    if ratio > mu:\n        # More aggressive update when residuals are very imbalanced\n        # Scale step size by how much ratio exceeds mu\n        scale = min(2.0, ratio / mu)\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n        aux = t * scale  # Capture update magnitude\n        \n    elif 1.0 / ratio > mu:\n        # Dual residual is much larger\n        scale = min(2.0, (1.0 / ratio) / mu)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n        aux = t * scale\n        \n    else:\n        # Residuals are balanced\n        new_rho = rho\n        mode = \"keep\"\n        # aux reflects how balanced residuals are\n        aux = abs(ratio - 1.0)\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 3 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on combined_score (0.0769), Performs well on metrics ({'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}), Performs well on artifacts ({'status': 'CONVERGED', 'iterations': 13, 'eval_time': '27.119s'}), Performs well on formal_certification (Lean4_Auto_Proven)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0385)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic with adaptive scaling based on residual ratio\n    # Compute safe ratios\n    r_ratio = r_norm / max(s_norm, eps)\n    s_ratio = s_norm / max(r_norm, eps)\n    \n    if r_ratio > mu:\n        # Scale the step size by how much the ratio exceeds mu, but cap it conservatively\n        scale = min(r_ratio / mu, 1.5)  # Reduced cap to 1.5 for more stability\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n    elif s_ratio > mu:\n        scale = min(s_ratio / mu, 1.5)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to metrics\n\n### Program D2 (Score: 0.0385)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic with adaptive scaling based on residual ratio\n    # Compute safe ratios\n    r_ratio = r_norm / max(s_norm, eps)\n    s_ratio = s_norm / max(r_norm, eps)\n    \n    if r_ratio > mu:\n        # Scale the step size by how much the ratio exceeds mu, but cap it\n        scale = min(r_ratio / mu, 5.0)  # Cap at 5 to prevent too large steps\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n    elif s_ratio > mu:\n        scale = min(s_ratio / mu, 5.0)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to metrics\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5000, Type: Experimental)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence with slower decay for more updates.\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Slightly more aggressive threshold\n    c=1.0,\n    p=1.1,   # Make step size diminish slower for more updates\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with improved responsiveness.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Compute residual ratio for more nuanced update\n    ratio = r_norm / max(s_norm, eps)\n    \n    # Direction logic with smoother transitions\n    if ratio > mu:\n        # More aggressive update when residuals are very imbalanced\n        # Scale step size by how much ratio exceeds mu\n        scale = min(2.0, ratio / mu)\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n        aux = t * scale  # Capture update magnitude\n        \n    elif 1.0 / ratio > mu:\n        # Dual residual is much larger\n        scale = min(2.0, (1.0 / ratio) / mu)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n        aux = t * scale\n        \n    else:\n        # Residuals are balanced\n        new_rho = rho\n        mode = \"keep\"\n        # aux reflects how balanced residuals are\n        aux = abs(ratio - 1.0)\n\n    return new_rho, aux, mode\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0385, Type: Exploratory)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic based on residual ratios (conservative)\n    # Compute safe ratios\n    r_ratio = r_norm / max(s_norm, eps)\n    s_ratio = s_norm / max(r_norm, eps)\n    \n    if r_ratio > mu:\n        # Use fixed step size without scaling for C1-safety\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n    elif s_ratio > mu:\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], NumPy-based implementation\n\n### Inspiration 3 (Score: 0.0385, Type: Exploratory)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic with adaptive scaling based on residual ratio\n    # Compute safe ratios\n    r_ratio = r_norm / max(s_norm, eps)\n    s_ratio = s_norm / max(r_norm, eps)\n    \n    if r_ratio > mu:\n        # Scale the step size by how much the ratio exceeds mu, but cap it conservatively\n        scale = min(r_ratio / mu, 1.5)  # Reduced cap to 1.5 for more stability\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n    elif s_ratio > mu:\n        scale = min(s_ratio / mu, 1.5)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], NumPy-based implementation\n\n# Current Program\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.1):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    # Ensure k is at least 0 to avoid division by zero\n    return c / ((max(k, 0) + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Reduced from 3.0 to be more responsive\n    c=1.0,\n    p=1.1,   # Slightly reduced to make step sizes decay slower\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with improved responsiveness.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Additional step size for division to be more aggressive\n    t_div = tau(k, c=0.8, p=1.1)  # Smaller base for division updates\n\n    # Direction logic with more nuanced conditions\n    # Calculate the ratio of residuals\n    if s_norm > eps:\n        ratio = r_norm / s_norm\n    else:\n        ratio = r_norm / eps\n    \n    if ratio > mu:\n        # More aggressive multiplication when primal residual is much larger\n        new_rho = rho * (1.0 + 1.5 * t)  # Increased factor\n        mode = \"mul\"\n        # aux reflects the degree of imbalance\n        aux = min(ratio / mu, 10.0)  # Cap at 10.0 for stability\n\n    elif 1.0 / ratio > mu:\n        # More responsive division when dual residual is much larger\n        new_rho = rho / (1.0 + 1.2 * t_div)  # Using t_div\n        mode = \"div\"\n        aux = min(mu * s_norm / max(r_norm, eps), 10.0)\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n        aux = 1.0  # Neutral auxiliary value\n\n    return new_rho, aux, mode\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["Looking at the current program, I notice it has a fitness score of 0.5000, which is tied with the top performers. However, the last execution resulted in a timeout during evaluation, which suggests the program might be too complex or inefficient. The code length exceeds 500 characters, and the system suggests simplifying it.\n\nThe current program uses two different step sizes (t and t_div) and has complex auxiliary calculations. This might be causing the timeout. Let's aim to simplify the implementation while maintaining effectiveness.\n\nKey observations from top performers:\n1. Program 2 uses a single step size and scales it based on the residual ratio, which seems effective.\n2. The current program uses different step sizes for multiplication and division, which may be unnecessary.\n3. The auxiliary value (aux) in the current program is computed in a way that depends on residuals, which might violate C1-safety? But the requirements say aux can depend on residuals? Wait, the documentation says \"Auxiliary scalar: purely tau_k (no residual dependence)\" in some programs, but others have residual-dependent aux.\n\nActually, looking at the requirements, the auxiliary scalar must be summable and independent of residuals for C1-safety. The current program's aux depends on residuals, which might be problematic.\n\nLet's simplify:\n1. Use a single step size t\n2. Make aux purely t (or a function of t only)\n3. Reduce complexity to avoid timeout\n\nHere's a simplified version that should be faster and still effective:\n\n<<<<<<< SEARCH\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Reduced from 3.0 to be more responsive\n    c=1.0,\n    p=1.1,   # Slightly reduced to make step sizes decay slower\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with improved responsiveness.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Additional step size for division to be more aggressive\n    t_div = tau(k, c=0.8, p=1.1)  # Smaller base for division updates\n\n    # Direction logic with more nuanced conditions\n    # Calculate the ratio of residuals\n    if s_norm > eps:\n        ratio = r_norm / s_norm\n    else:\n        ratio = r_norm / eps\n    \n    if ratio > mu:\n        # More aggressive multiplication when primal residual is much larger\n        new_rho = rho * (1.0 + 1.5 * t)  # Increased factor\n        mode = \"mul\"\n        # aux reflects the degree of imbalance\n        aux = min(ratio / mu, 10.0)  # Cap at 10.0 for stability\n\n    elif 1.0 / ratio > mu:\n        # More responsive division when dual residual is much larger\n        new_rho = rho / (1.0 + 1.2 * t_div)  # Using t_div\n        mode = \"div\"\n        aux = min(mu * s_norm / max(r_norm, eps), 10.0)\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n        aux = 1.0  # Neutral auxiliary value\n\n    return new_rho, aux, mode\n=======\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,  # Balanced threshold\n    c=1.0,\n    p=1.1,\n    eps=1e-12,\n):\n    \"\"\"\n    Simplified C1-safe adaptive ADMM penalty update rule.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Compute safe ratio\n    ratio = r_norm / max(s_norm, eps)\n    \n    # Direction logic with single step size\n    if ratio > mu:\n        # Scale step size by how much ratio exceeds mu, but cap for stability\n        scale = min(ratio / mu, 2.0)\n        new_rho = rho * (1.0 + t * scale)\n        mode = \"mul\"\n    elif 1.0 / ratio > mu:\n        scale = min((1.0 / ratio) / mu, 2.0)\n        new_rho = rho / (1.0 + t * scale)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n    \n    # Auxiliary scalar: purely tau_k (no residual dependence) for C1-safety\n    aux = t\n    \n    return new_rho, aux, mode\n>>>>>>> REPLACE\n\nThis change simplifies the code by:\n1. Removing the separate t_div calculation\n2. Using a single step size t for both multiplication and division\n3. Making aux purely t (independent of residuals) to ensure C1-safety\n4. Reducing the number of operations and branches\n5. Keeping the scaling factor capped at 2.0 for stability\n\nThis should help avoid the timeout by being more efficient while maintaining good performance. The fitness score might improve because:\n1. Simpler code runs faster, reducing evaluation time\n2. C1-safety is preserved with aux = t\n3. The scaling approach is similar to Program 2 which has high fitness\n\nLet's also update the docstring to reflect the changes:\n\n<<<<<<< SEARCH\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with improved responsiveness.\n    \"\"\"\n=======\n    \"\"\"\n    Simplified C1-safe adaptive ADMM penalty update rule.\n    Uses a single step size with adaptive scaling for better convergence.\n    \"\"\"\n>>>>>>> REPLACE\n\nThese changes should make the program more efficient and potentially improve its fitness score by avoiding timeout while maintaining effectiveness."]}}, "artifacts_json": "{\"timeout\": true, \"timeout_duration\": 120, \"failure_stage\": \"evaluation\", \"error_type\": \"timeout\"}", "artifact_dir": null, "embedding": null}