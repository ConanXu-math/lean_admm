Your task is **mechanical translation** from a given mathematical specification to Lean 4, following **exact syntactic and structural conventions** from the reference examples.

You must **not invent, optimize, refactor, or simplify** anything.

---

## üì• Inputs

You will be provided with **two sections**:

---

## üìò SECTION 1 ‚Äî Mathematical Specification (to be translated)

This section contains a **LaTeX-style mathematical formulation**.

You must translate it into Lean 4 **faithfully and literally**, without adding or removing content.

```latex
{mathematical_formulation}
```

---

## üìú SECTION 2 ‚Äî Reference Example(s) (BINDING)

This section contains **one or more complete reference examples**, each consisting of:

1. A mathematical formulation
2. Its corresponding Lean 4 implementation

These examples define **binding conventions**.

You must treat them as **authoritative templates** for:

* naming
* argument order
* structure
* proof shape
* tactic usage
* case split order

You may have **multiple examples**; all of them must be respected.

### ‚ú® Example 1 ‚Äî Mathematical formulation

```latex
Let \( \mathbb{N} := \{0,1,2,\dots\} \).
Let \( \varepsilon > 0 \) and \( \mu > 1 \) be fixed real constants.
Let \( c > 0, p > 1 \) be fixed real constants.

Define sequences:
\[
\{ r_k \}_{k \in \mathbb{N}}, \quad \{ s_k \}_{k \in \mathbb{N}}, \quad \{ \rho_k \}_{k \in \mathbb{N}} \subset \mathbb{R}_+, \quad \{ \tau_k \}_{k \in \mathbb{N}} \subset \mathbb{R}_+.
\]

Auxiliary definition:
\[
\tau_k := \frac{c}{(k+1)^p}, \qquad k \in \mathbb{N}.
\]

Define for each \( k \):
\[
\bar r_k := \frac{r_k}{\max(s_k, \varepsilon)}, \qquad
\bar s_k := \frac{s_k}{\max(r_k, \varepsilon)}.
\]

Define direction function \( \text{dir}_k \in \{-1,0,1\} \):
\[
\text{dir}_k :=
\begin{cases}
1, & \bar r_k > \mu, \\
-1, & \bar s_k > \mu, \\
0, & \text{otherwise}.
\end{cases}
\]

Recurrence for \( \rho_k \):
\[
\rho_{k+1} :=
\begin{cases}
\rho_k (1 + \tau_k), & \text{dir}_k = 1, \\
\rho_k / (1 + \tau_k), & \text{dir}_k = -1, \\
\rho_k, & \text{dir}_k = 0,
\end{cases}
\qquad k \in \mathbb{N}.
\]

Post-update clipping:
\[
\rho_{k+1} := \min\big( \max( \rho_{k+1}, 10^{-6} ), 10^{6} \big).
\]

(Optional auxiliary for logging):
\[
a_k := \max( \bar r_k, \bar s_k ).
\]
```

### üß† Example 1 ‚Äî Lean 4 Code

```lean
-- AUTO GENERATED Lean4 FILE
import Optlib.Algorithm.AdaptiveADMM.Strategies.Adaptive_Strategy_Convergence
import Optlib.Algorithm.AdaptiveADMM.Strategies.VerificationLib

noncomputable section

open Topology Filter
open AdaptiveADMM_Convergence_Proof
open AdaptiveADMM_Verification

variable {E‚ÇÅ E‚ÇÇ F : Type*}
[NormedAddCommGroup E‚ÇÅ] [InnerProductSpace ‚Ñù E‚ÇÅ] [FiniteDimensional ‚Ñù E‚ÇÅ]
[NormedAddCommGroup E‚ÇÇ] [InnerProductSpace ‚Ñù E‚ÇÇ] [FiniteDimensional ‚Ñù E‚ÇÇ]
[NormedAddCommGroup F] [InnerProductSpace ‚Ñù F] [FiniteDimensional ‚Ñù F]

variable (admm : ADMM E‚ÇÅ E‚ÇÇ F)

def tau_seq (c p : ‚Ñù) (n : ‚Ñï) : ‚Ñù := c / Real.rpow ((n : ‚Ñù) + 1) p

theorem h_tau_summable (c p : ‚Ñù) (hp : 1 < p) : Summable (tau_seq c p) := by
  exact p_series_summable_template c p hp

def r_ratio (r_norm_seq s_norm_seq : ‚Ñï ‚Üí ‚Ñù) (eps : ‚Ñù) (n : ‚Ñï) : ‚Ñù :=
  r_norm_seq n / max (s_norm_seq n) eps

def s_ratio (r_norm_seq s_norm_seq : ‚Ñï ‚Üí ‚Ñù) (eps : ‚Ñù) (n : ‚Ñï) : ‚Ñù :=
  s_norm_seq n / max (r_norm_seq n) eps

-- residual balancing: dir_seq n = 1 (mul), 0 (keep), -1 (div)
def dir_seq (mu eps : ‚Ñù) (r_norm_seq s_norm_seq : ‚Ñï ‚Üí ‚Ñù) (n : ‚Ñï) : ‚Ñ§ :=
  if r_ratio r_norm_seq s_norm_seq eps n > mu then 1
  else if s_ratio r_norm_seq s_norm_seq eps n > mu then -1 else 0

lemma h_dir (mu eps : ‚Ñù) (r_norm_seq s_norm_seq : ‚Ñï ‚Üí ‚Ñù) :
    ‚àÄ n, dir_seq mu eps r_norm_seq s_norm_seq n = 1 ‚à®
         dir_seq mu eps r_norm_seq s_norm_seq n = 0 ‚à®
         dir_seq mu eps r_norm_seq s_norm_seq n = -1 := by
  intro n
  by_cases h1 : r_ratio r_norm_seq s_norm_seq eps n > mu
  ¬∑ simp [dir_seq, h1]
  ¬∑ by_cases h2 : s_ratio r_norm_seq s_norm_seq eps n > mu
    ¬∑ simp [dir_seq, h1, h2]
    ¬∑ simp [dir_seq, h1, h2]

-- Âü∫‰∫é dir_seq ÁöÑ‰∏âÊÄÅÊõ¥Êñ∞
def update_fun (tau : ‚Ñï ‚Üí ‚Ñù) (dir : ‚Ñï ‚Üí ‚Ñ§) (n : ‚Ñï) (rho : ‚Ñù) : ‚Ñù :=
  if dir n = (-1 : ‚Ñ§) then
    rho / (1 + tau n)
  else if dir n = (1 : ‚Ñ§) then
    rho * (1 + tau n)
  else
    rho

lemma h_update_equiv (tau : ‚Ñï ‚Üí ‚Ñù) (dir : ‚Ñï ‚Üí ‚Ñ§)
    (h_dir : ‚àÄ n, dir n = 1 ‚à® dir n = 0 ‚à® dir n = -1) :
    ‚àÄ n rho, 0 < rho ‚Üí
      update_fun tau dir n rho = rho * (1 + tau n) ‚à®
      update_fun tau dir n rho = rho / (1 + tau n) ‚à®
      update_fun tau dir n rho = rho := by
  intro n rho hœÅ_pos
  rcases h_dir n with h | h | h
  ¬∑ left; simp [update_fun, h]
  ¬∑ right; right; simp [update_fun, h]
  ¬∑ right; left; simp [update_fun, h]

theorem auto_converges
    (admm_kkt : Existance_of_kkt admm)
    [Setting E‚ÇÅ E‚ÇÇ F admm admm_kkt]
    [IsOrderedMonoid ‚Ñù]
    (mu eps c p : ‚Ñù)
    (hp : 1 < p)
    (r_norm_seq s_norm_seq : ‚Ñï ‚Üí ‚Ñù)
    (h_tau_nonneg : ‚àÄ n, 0 ‚â§ tau_seq c p n)
    (h_rho : ‚àÄ n, admm.œÅ‚Çô (n+1) = update_fun (tau_seq c p) (dir_seq mu eps r_norm_seq s_norm_seq) n (admm.œÅ‚Çô n))
    (fullrank‚ÇÅ : Function.Injective admm.A‚ÇÅ)
    (fullrank‚ÇÇ : Function.Injective admm.A‚ÇÇ) :
    ‚àÉ x‚ÇÅ x‚ÇÇ y,
  Convex_KKT x‚ÇÅ x‚ÇÇ y admm.toOptProblem ‚àß
  Tendsto admm.x‚ÇÅ atTop (ùìù x‚ÇÅ) ‚àß
  Tendsto admm.x‚ÇÇ atTop (ùìù x‚ÇÇ) ‚àß
  Tendsto admm.y atTop (ùìù y) := by
  let tau := tau_seq c p
  let dir := dir_seq mu eps r_norm_seq s_norm_seq
  have h_dir' : ‚àÄ n, dir n = 1 ‚à® dir n = 0 ‚à® dir n = -1 := by
    intro n; simpa [dir] using h_dir mu eps r_norm_seq s_norm_seq n
  let s : AdaptableStrategy (admm := admm) (admm_kkt := admm_kkt) :=
    { tau_seq := tau
      h_tau_nonneg := h_tau_nonneg
      h_tau_summable := h_tau_summable c p hp
      update_fun := update_fun tau dir
      h_update_equiv := h_update_equiv tau dir h_dir' }
  apply Strategy3.converges_from_adaptable_strategy (admm := admm) (admm_kkt := admm_kkt) s h_rho fullrank‚ÇÅ fullrank‚ÇÇ
```

---

## üß± Global Hard Constraints (FINAL ¬∑ Internally Consistent)

### 1Ô∏è‚É£ Output Rules

* Output **Lean 4 code only**
* Wrap the entire output in **one** triple-backtick block

  ```lean
  ...
  ```
* No prose, no explanations, no comments outside the code block

---

### 2Ô∏è‚É£ Allowed Lean Constructs (STRICT WHITELIST)

You may use **only** constructs that appear in the reference examples, including:

* `def`
* `lemma`
* `theorem`
* `if ... then ... else`
* tactic blocks: `by`
* tactics: `intro`, `have`, `rcases`, `by_cases`, `simp`
* tactic-level `let` (inside `by` blocks only)

üö´ **Forbidden**:

* `match`
* `calc`
* `cases`
* `funext`
* term-level `let ... in ...`
* `ring`, `ring_nf`, `linarith`, `nlinarith`
* any construct not present in the reference code

---

### 3Ô∏è‚É£ Structural Invariants (ABSOLUTE)

The following identifiers **must exist** and must have the **same type, argument order, and role** as in the reference examples (only parameter names may differ):

#### Definitions

* `dir_seq : ‚Ñï ‚Üí ‚Ñ§`
* `update_fun : (‚Ñï ‚Üí ‚Ñù) ‚Üí (‚Ñï ‚Üí ‚Ñ§) ‚Üí ‚Ñï ‚Üí ‚Ñù ‚Üí ‚Ñù`

#### Lemmas

* `h_dir`
* `h_update_equiv`

#### Theorem

* `auto_converges`

üö´ Do NOT:

* rename them
* change argument order
* add extra parameters
* generalize or strengthen their statements

---

### 4Ô∏è‚É£ Case Logic Alignment Rule (CRITICAL)

**The case order MUST be consistent across all components.**

The canonical case order is:

1. `dir n = -1`
2. `dir n = 1`
3. `dir n = 0`

This order MUST be used in:

* the nested `if ... then ... else` of `update_fun`
* the disjunction order returned by `h_dir`
* the `rcases` pattern used in `h_update_equiv`

üö´ Any mismatch between these orders is forbidden.

---

### 5Ô∏è‚É£ Direction Function Rules

* `dir_seq` **must return ‚Ñ§**
* It must return **only** `-1`, `1`, or `0`
* It must be implemented using **nested `if`**, not `match`
* The `if` order MUST follow the canonical case order in Rule 4

---

### 6Ô∏è‚É£ Update Function Rule (Single Definition, No Raw Version)

* There MUST be exactly **one** definition named `update_fun`
* `update_fun` MUST use the canonical case order:

  1. `dir n = -1`
  2. `dir n = 1`
  3. otherwise
* Any clipping (`min` / `max`) MUST wrap the entire `if ... then ... else`
* Any additional factors (e.g. `scale n`) are **implementation details**
  and MUST appear only inside `update_fun`

üö´ Forbidden:

* defining `update_fun_raw`
* conditional clipping
* exposing implementation factors outside `update_fun`

---

### 7Ô∏è‚É£ Update Equivalence Lemma (INTERFACE LEMMA)

`h_update_equiv` is an **interface-level lemma** required by `AdaptableStrategy`.

It MUST:

* use the same canonical case order as Rule 4
* have **exactly three disjuncts**, in this order:

  1. `update_fun ... = rho * (1 + tau n)`
  2. `update_fun ... = rho / (1 + tau n)`
  3. `update_fun ... = rho`
* use **exactly** this proof skeleton:

```lean
intro n rho hœÅ_pos
rcases h_dir n with h | h | h
¬∑ simp [update_fun, h]
¬∑ simp [update_fun, h]
¬∑ simp [update_fun, h]
```

üö´ Do NOT:

* mention any additional factors (`scale`, weights, etc.) in the statement
* reorder disjuncts
* introduce auxiliary lemmas
* expand arithmetic expressions

---

### 8Ô∏è‚É£ Summability Lemma Canonical Form (MANDATORY)

For any sequence defined by a `def` (e.g. `tau_seq`):

* The summability proof MUST normalize the goal using `simpa`
* The following pattern is **mandatory**:

```lean
theorem h_tau_summable (c p : ‚Ñù) (hp : 1 < p) :
  Summable (tau_seq c p) := by
  simpa [tau_seq] using p_series_summable_template c p hp
```

üö´ Forbidden:

* using `exact p_series_summable_template ...`
* omitting the `simpa [tau_seq]`

---

### 9Ô∏è‚É£ Definition and Lemma Order (STRICT)

All code must appear in the following order:

1. helper / sequence `def`s
2. `dir_seq`
3. `h_dir`
4. `update_fun`
5. `h_update_equiv`
6. `auto_converges`

---

### üîç Mandatory Internal Self-Check

Before producing the final output, internally verify:

* all case orders match Rule 4
* `dir_seq` returns ‚Ñ§
* `update_fun` has no free variables
* `h_update_equiv` uses **only** `(1 + tau n)`
* summability lemmas use `simpa [definition]`
* no forbidden constructs appear

If any check fails, **rewrite before outputting**.

---

### üì§ Final Output

Return **only**:

```lean
-- AUTO GENERATED Lean4 FILE
<complete Lean 4 code>
```

Nothing else.

---