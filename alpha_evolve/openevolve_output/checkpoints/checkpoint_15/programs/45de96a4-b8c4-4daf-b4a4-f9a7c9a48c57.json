{"id": "45de96a4-b8c4-4daf-b4a4-f9a7c9a48c57", "code": "# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,\n    c=1.0,\n    p=1.1,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n    Balanced approach with fixed threshold and slower diminishing step.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n    return new_rho, aux, mode\n", "language": "python", "parent_id": "341ac903-a13e-4b45-b97f-ca20ed09438a", "generation": 3, "timestamp": 1770451601.4119859, "iteration_found": 14, "metrics": {"combined_score": 0.07692307692307693, "metrics": {"converged": true, "iters": 13, "combined_score": 0.07692307692307693}, "artifacts": {"status": "CONVERGED", "iterations": 13, "eval_time": "19.979s"}, "formal_certification": "Lean4_Auto_Proven"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 45 lines with 31 lines", "parent_metrics": {"combined_score": 0.07692307692307693, "metrics": {"converged": true, "iters": 13, "combined_score": 0.07692307692307693}, "artifacts": {"status": "CONVERGED", "iterations": 13, "eval_time": "27.188s"}, "formal_certification": "Lean4_Auto_Proven"}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.0769\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0769\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Metrics: combined_score: 0.0769, metrics: {'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}, artifacts: {'status': 'CONVERGED', 'iterations': 13, 'eval_time': '20.735s'}, formal_certification: Lean4_Auto_Proven\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Change 1: Replace 36 lines with 44 lines\nChange 2: Replace 3 lines with 4 lines\n- Metrics: combined_score: 0.0769, metrics: {'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}, artifacts: {'status': 'CONVERGED', 'iterations': 13, 'eval_time': '21.544s'}, formal_certification: Lean4_Auto_Proven\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 36 lines with 36 lines\nChange 2: Replace 10 lines with 10 lines\n- Metrics: combined_score: 0.0769, metrics: {'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}, artifacts: {'status': 'CONVERGED', 'iterations': 13, 'eval_time': '21.675s'}, formal_certification: Lean4_Auto_Proven\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.2, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on combined_score (0.0769), Performs well on metrics ({'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}), Performs well on artifacts ({'status': 'CONVERGED', 'iterations': 13, 'eval_time': '21.675s'}), Performs well on formal_certification (Lean4_Auto_Proven)\n\n### Program 2 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n    # Adjust mu to decrease with iterations for finer convergence\n    # As k increases, mu approaches 1.0, making the condition stricter\n    # Start at mu and approach 1.0\n    adjusted_mu = 1.0 + (mu - 1.0) / (k + 1.0)\n    \n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Protect against division by zero\n    # Use max with eps only when necessary\n    r_protected = max(r_norm, eps)\n    s_protected = max(s_norm, eps)\n    \n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > adjusted_mu * s_protected:\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > adjusted_mu * r_protected:\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on combined_score (0.0769), Performs well on metrics ({'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}), Performs well on artifacts ({'status': 'CONVERGED', 'iterations': 13, 'eval_time': '21.544s'}), Performs well on formal_certification (Lean4_Auto_Proven)\n\n### Program 3 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on combined_score (0.0769), Performs well on metrics ({'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}), Performs well on artifacts ({'status': 'CONVERGED', 'iterations': 13, 'eval_time': '20.735s'}), Performs well on formal_certification (Lean4_Auto_Proven)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design with adaptive threshold.\n    \"\"\"\n    # Adjust mu to become stricter as iterations increase\n    # This helps in finer convergence control\n    adjusted_mu = 1.0 + (mu - 1.0) / (k + 1.0)\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > adjusted_mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > adjusted_mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to metrics\n\n### Program D2 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.2, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design, similar to top performers.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to metrics\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0769, Type: Exploratory)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], NumPy-based implementation, Comprehensive implementation\n\n### Inspiration 2 (Score: 0.0769, Type: Exploratory)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.2, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], NumPy-based implementation\n\n### Inspiration 3 (Score: 0.0385, Type: Exploratory)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule with dynamic threshold.\n\n    More aggressive updates for faster convergence.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Dynamic mu that decreases with iterations to become more sensitive\n    # Start with mu and reduce it gradually\n    dynamic_mu = mu / (1.0 + 0.1 * k)\n    \n    # Determine update direction\n    if r_norm > dynamic_mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n    elif s_norm > dynamic_mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n    else:\n        # When residuals are balanced, make a small adjustment based on their ratio\n        # This can help fine-tune convergence\n        if r_norm > s_norm:\n            # r_norm is slightly larger, increase rho slightly\n            new_rho = rho * (1.0 + 0.5 * t)\n            mode = \"small_mul\"\n        elif s_norm > r_norm:\n            # s_norm is slightly larger, decrease rho slightly\n            new_rho = rho / (1.0 + 0.5 * t)\n            mode = \"small_div\"\n        else:\n            new_rho = rho\n            mode = \"keep\"\n    \n    # Auxiliary scalar: track the adjustment factor\n    aux = t\n    \n    return new_rho, aux, mode\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], NumPy-based implementation\n\n# Current Program\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n    # Adjust mu to decrease with iterations for finer convergence\n    # As k increases, mu approaches 1.0, making the condition stricter\n    # Start at mu and approach 1.0\n    adjusted_mu = 1.0 + (mu - 1.0) / (k + 1.0)\n    \n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Protect against division by zero\n    # Use max with eps only when necessary\n    r_protected = max(r_norm, eps)\n    s_protected = max(s_norm, eps)\n    \n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > adjusted_mu * s_protected:\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > adjusted_mu * r_protected:\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["Looking at the current program, I notice it's very similar to Program 2 in the top performers, which has the same fitness score (0.0769). The current program uses an adjusted mu that decreases with iterations and protects both residuals with eps individually. However, the fitness hasn't improved beyond 0.0769, and the history shows that all attempts have converged to this score.\n\nTo potentially improve the fitness score, I need to explore different approaches while maintaining the C1-safe property. The fitness score seems to be related to the number of iterations (13) and convergence status. Perhaps we can try to reduce the number of iterations or improve convergence speed by making the update rule more responsive while still being conservative.\n\nNotice that Inspiration 3 has a lower score (0.0385) and uses a more aggressive approach with dynamic mu and additional small adjustments. This suggests that being too aggressive might not be good. However, the current approach might be too conservative.\n\nLet's try a balanced approach that:\n1. Uses a different adjustment for mu that doesn't approach 1.0 too quickly\n2. Uses a different step size parameter to potentially speed up convergence\n3. Simplifies the code to reduce length (as noted: \"code length exceeds 500 characters\")\n\nThe current program has 44 lines. Let's count: it's actually 44 lines including comments and blank lines. We can try to make it more concise while adding a different feature.\n\nHere's an idea: use a different adjustment for mu that depends on the ratio of residuals, but still summable. Also, let's try using a different p value in tau to make the step size diminish at a different rate.\n\nWait, the note says \"Consider simplifying - code length exceeds 500 characters\". Let's check the character count. The current program has about 1500 characters. So we can try to make it more concise.\n\nBut more importantly, we need to improve fitness. Let's look at the metrics: all top programs have 13 iterations and converged. Perhaps we can reduce iterations to 12 or less? That might improve the combined score.\n\nLet's try a different approach: use a mu that adjusts based on the progress of residuals, but in a summable way. However, the auxiliary scalar must only depend on k and fixed constants. So we can't use residuals there.\n\nActually, the auxiliary scalar is just t, which is tau(k). That's fine.\n\nLet's try to modify the update conditions to be more sensitive when residuals are imbalanced, but still conservative. We can try using a mu that decreases more slowly, or even increases initially? No, that might not be C1-safe.\n\nWait, the C1-safe property requires that the update direction depends only on residuals, and the step size is summable and independent of residuals. Our changes must respect this.\n\nLet's try a different adjustment for mu: instead of approaching 1.0, let it approach 2.0? Actually, mu=3.0 in the current program, and adjusted_mu = 1.0 + (mu - 1.0)/(k+1). So it starts at mu=3.0 and approaches 1.0. This makes the condition stricter over time.\n\nPerhaps we want the opposite: start stricter and become more lenient? Or use a fixed mu? Program 1 uses mu=2.0 and no adjustment, and has the same fitness.\n\nLet's try a hybrid: use a fixed mu but with a different step size parameter c. Also, simplify the code by removing the adjusted_mu and the separate protection lines.\n\nHere's a plan:\n1. Use mu=2.5 (between 2.0 and 3.0)\n2. Use a different p=1.1 to make step size diminish slower\n3. Simplify the code by removing adjusted_mu and the separate r_protected, s_protected\n4. Keep the same structure but with fewer lines\n\nLet's implement:\n\n<<<<<<< SEARCH\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n    # Adjust mu to decrease with iterations for finer convergence\n    # As k increases, mu approaches 1.0, making the condition stricter\n    # Start at mu and approach 1.0\n    adjusted_mu = 1.0 + (mu - 1.0) / (k + 1.0)\n    \n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Protect against division by zero\n    # Use max with eps only when necessary\n    r_protected = max(r_norm, eps)\n    s_protected = max(s_norm, eps)\n    \n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > adjusted_mu * s_protected:\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > adjusted_mu * r_protected:\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n=======\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.5,\n    c=1.0,\n    p=1.1,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n    Balanced approach with fixed threshold and slower diminishing step.\n    \"\"\"\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n    \n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n    return new_rho, aux, mode\n>>>>>>> REPLACE\n\nThis change:\n1. Reduces code length by removing adjusted_mu and separate protection variables\n2. Uses a fixed mu=2.5 (a middle ground between 2.0 and 3.0 from top programs)\n3. Uses p=1.1 which makes the step size diminish slower than p=1.2, potentially allowing more updates in later iterations\n4. Keeps the same conservative structure but with different parameters\n\nThis approach is different from existing programs (which use mu=2.0, 3.0, or adjusted mu) and uses a different p value, adding diversity. The fitness might improve if the slower diminishing step helps convergence in fewer iterations.\n\nLet's also update the tau function to use the same p default? Actually, the tau function has its own default p=1.2, but we're passing p=1.1 from update_rho. That's fine.\n\nThis change makes the code more concise (reducing from 44 lines to about 35 lines), addressing the note about code length.\n\nLet's also update the docstring to reflect the changes.\n\nThis is a balanced approach that might improve convergence speed while maintaining the C1-safe property. Let's see if it can reduce the number of iterations below 13."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}