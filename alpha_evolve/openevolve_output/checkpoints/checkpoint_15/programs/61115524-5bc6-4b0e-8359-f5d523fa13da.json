{"id": "61115524-5bc6-4b0e-8359-f5d523fa13da", "code": "# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design with adaptive threshold.\n    \"\"\"\n    # Adjust mu to become stricter as iterations increase\n    # This helps in finer convergence control\n    adjusted_mu = 1.0 + (mu - 1.0) / (k + 1.0)\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > adjusted_mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > adjusted_mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n", "language": "python", "parent_id": "a24d2473-d2c8-4342-99e2-ceaed93db962", "generation": 2, "timestamp": 1770451254.8366249, "iteration_found": 11, "metrics": {"combined_score": 0.07692307692307693, "metrics": {"converged": true, "iters": 13, "combined_score": 0.07692307692307693}, "artifacts": {"status": "CONVERGED", "iterations": 13, "eval_time": "21.236s"}, "formal_certification": "Lean4_Auto_Proven"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 12 lines with 10 lines\nChange 2: Replace 51 lines with 39 lines", "parent_metrics": {"combined_score": 0.041666666666666664, "metrics": {"converged": true, "iters": 12, "combined_score": 0.041666666666666664}, "artifacts": {"status": "CONVERGED", "iterations": 12, "eval_time": "24.987s"}, "formal_certification": "Lean4_Not_Auto_Proven"}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.0417\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.0769 \u2192 0.0417. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Metrics: combined_score: 0.0769, metrics: {'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}, artifacts: {'status': 'CONVERGED', 'iterations': 13, 'eval_time': '20.735s'}, formal_certification: Lean4_Auto_Proven\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Change 1: Replace 36 lines with 44 lines\nChange 2: Replace 3 lines with 4 lines\n- Metrics: combined_score: 0.0769, metrics: {'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}, artifacts: {'status': 'CONVERGED', 'iterations': 13, 'eval_time': '21.544s'}, formal_certification: Lean4_Auto_Proven\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 36 lines with 36 lines\nChange 2: Replace 10 lines with 10 lines\n- Metrics: combined_score: 0.0769, metrics: {'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}, artifacts: {'status': 'CONVERGED', 'iterations': 13, 'eval_time': '21.675s'}, formal_certification: Lean4_Auto_Proven\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.2, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on combined_score (0.0769), Performs well on metrics ({'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}), Performs well on artifacts ({'status': 'CONVERGED', 'iterations': 13, 'eval_time': '21.675s'}), Performs well on formal_certification (Lean4_Auto_Proven)\n\n### Program 2 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n    # Adjust mu to decrease with iterations for finer convergence\n    # As k increases, mu approaches 1.0, making the condition stricter\n    # Start at mu and approach 1.0\n    adjusted_mu = 1.0 + (mu - 1.0) / (k + 1.0)\n    \n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Protect against division by zero\n    # Use max with eps only when necessary\n    r_protected = max(r_norm, eps)\n    s_protected = max(s_norm, eps)\n    \n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > adjusted_mu * s_protected:\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > adjusted_mu * r_protected:\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on combined_score (0.0769), Performs well on metrics ({'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}), Performs well on artifacts ({'status': 'CONVERGED', 'iterations': 13, 'eval_time': '21.544s'}), Performs well on formal_certification (Lean4_Auto_Proven)\n\n### Program 3 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Performs well on combined_score (0.0769), Performs well on metrics ({'converged': True, 'iters': 13, 'combined_score': 0.07692307692307693}), Performs well on artifacts ({'status': 'CONVERGED', 'iterations': 13, 'eval_time': '20.735s'}), Performs well on formal_certification (Lean4_Auto_Proven)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0417)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence with faster initial decay.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    # Add a small constant to prevent division by zero\n    # Adjust to decay faster initially\n    return c / ((k + 2.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Enhanced direction logic with balanced thresholds\n    # Compute ratio of residuals\n    ratio = r_norm / max(s_norm, eps)\n    \n    # More nuanced update conditions\n    if ratio > mu:\n        # Increase rho more aggressively when r_norm is much larger\n        new_rho = rho * (1.0 + 2.0 * t)\n        mode = \"mul\"\n        aux = ratio  # Store the ratio for information\n\n    elif ratio < 1.0 / mu:\n        # Decrease rho more aggressively when s_norm is much larger\n        new_rho = rho / (1.0 + 2.0 * t)\n        mode = \"div\"\n        aux = ratio\n\n    else:\n        # Keep rho but adjust slightly towards balance\n        # Small adjustment based on which residual is larger\n        if r_norm > s_norm:\n            new_rho = rho * (1.0 + 0.5 * t)\n            mode = \"adjust_up\"\n        elif s_norm > r_norm:\n            new_rho = rho / (1.0 + 0.5 * t)\n            mode = \"adjust_down\"\n        else:\n            new_rho = rho\n            mode = \"keep\"\n        aux = ratio\n\n    return new_rho, aux, mode\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to metrics\n\n### Program D2 (Score: 0.0769)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design with adaptive threshold.\n    \"\"\"\n    # Adjust mu to become stricter as iterations increase\n    # This helps in finer convergence control\n    adjusted_mu = 1.0 + (mu - 1.0) / (k + 1.0)\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > adjusted_mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > adjusted_mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to metrics\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0769, Type: Exploratory)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], NumPy-based implementation, Comprehensive implementation\n\n### Inspiration 2 (Score: 0.0769, Type: Exploratory)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.2, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=2.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], NumPy-based implementation\n\n### Inspiration 3 (Score: 0.0385, Type: Exploratory)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n        aux = r_norm / max(s_norm, eps)  # Store ratio for information\n\n    elif s_norm > mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n        aux = r_norm / max(s_norm, eps)\n\n    else:\n        # Very small adjustment towards larger residual\n        if r_norm > s_norm:\n            new_rho = rho * (1.0 + 0.1 * t)\n            mode = \"tiny_mul\"\n        elif s_norm > r_norm:\n            new_rho = rho / (1.0 + 0.1 * t)\n            mode = \"tiny_div\"\n        else:\n            new_rho = rho\n            mode = \"keep\"\n        aux = t\n\n    return new_rho, aux, mode\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], NumPy-based implementation\n\n# Current Program\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence with faster initial decay.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    # Add a small constant to prevent division by zero\n    # Adjust to decay faster initially\n    return c / ((k + 2.0) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Enhanced direction logic with balanced thresholds\n    # Compute ratio of residuals\n    ratio = r_norm / max(s_norm, eps)\n    \n    # More nuanced update conditions\n    if ratio > mu:\n        # Increase rho more aggressively when r_norm is much larger\n        new_rho = rho * (1.0 + 2.0 * t)\n        mode = \"mul\"\n        aux = ratio  # Store the ratio for information\n\n    elif ratio < 1.0 / mu:\n        # Decrease rho more aggressively when s_norm is much larger\n        new_rho = rho / (1.0 + 2.0 * t)\n        mode = \"div\"\n        aux = ratio\n\n    else:\n        # Keep rho but adjust slightly towards balance\n        # Small adjustment based on which residual is larger\n        if r_norm > s_norm:\n            new_rho = rho * (1.0 + 0.5 * t)\n            mode = \"adjust_up\"\n        elif s_norm > r_norm:\n            new_rho = rho / (1.0 + 0.5 * t)\n            mode = \"adjust_down\"\n        else:\n            new_rho = rho\n            mode = \"keep\"\n        aux = ratio\n\n    return new_rho, aux, mode\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["Looking at the current program, I notice it has a fitness score of 0.0417, which is lower than the top-performing programs (0.0769). The current program has several differences from the successful ones:\n\n1. The `tau` function uses `k + 2.0` instead of `k + 1.0`, which changes the step size sequence.\n2. The update logic is more complex, with multiple adjustment modes and using a ratio-based approach.\n3. It uses aggressive multipliers (2.0 * t) and additional adjustments (0.5 * t) which may be too aggressive.\n4. The auxiliary variable `aux` is set to the ratio, which may violate the requirement that it should be independent of residuals (based on the top programs' comments).\n\nThe top-performing programs are simpler and follow a specific pattern:\n- Use `tau(k, c, p)` with `k + 1.0`\n- Compare `r_norm > mu * max(s_norm, eps)` and `s_norm > mu * max(r_norm, eps)`\n- Update with `1.0 + t` or `1.0 / (1.0 + t)`\n- Set `aux = t` (independent of residuals)\n\nLet's simplify the current program to be more in line with the successful approaches while keeping some unique elements for diversity. However, note that the fitness score dropped from 0.0769 to 0.0417, so recent changes likely made it worse.\n\nI'll suggest changes that:\n1. Revert `tau` to use `k + 1.0` (like top programs)\n2. Simplify the update logic to match the successful pattern\n3. Keep `aux` as `t` (independent of residuals)\n4. But maintain some unique feature for diversity, like using an adjusted mu that changes with iterations (as seen in Program 2 and D2)\n\nHere are the changes:\n\n<<<<<<< SEARCH\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence with faster initial decay.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    # Add a small constant to prevent division by zero\n    # Adjust to decay faster initially\n    return c / ((k + 2.0) ** p)\n=======\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size sequence.\n\n    Requirements:\n    - tau_k >= 0\n    - summable for p > 1\n    - depends only on k and fixed constants\n    \"\"\"\n    return c / ((k + 1.0) ** p)\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design.\n    \"\"\"\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Enhanced direction logic with balanced thresholds\n    # Compute ratio of residuals\n    ratio = r_norm / max(s_norm, eps)\n    \n    # More nuanced update conditions\n    if ratio > mu:\n        # Increase rho more aggressively when r_norm is much larger\n        new_rho = rho * (1.0 + 2.0 * t)\n        mode = \"mul\"\n        aux = ratio  # Store the ratio for information\n\n    elif ratio < 1.0 / mu:\n        # Decrease rho more aggressively when s_norm is much larger\n        new_rho = rho / (1.0 + 2.0 * t)\n        mode = \"div\"\n        aux = ratio\n\n    else:\n        # Keep rho but adjust slightly towards balance\n        # Small adjustment based on which residual is larger\n        if r_norm > s_norm:\n            new_rho = rho * (1.0 + 0.5 * t)\n            mode = \"adjust_up\"\n        elif s_norm > r_norm:\n            new_rho = rho / (1.0 + 0.5 * t)\n            mode = \"adjust_down\"\n        else:\n            new_rho = rho\n            mode = \"keep\"\n        aux = ratio\n\n    return new_rho, aux, mode\n=======\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    C1-safe adaptive ADMM penalty update rule.\n\n    Conservative by design with adaptive threshold.\n    \"\"\"\n    # Adjust mu to become stricter as iterations increase\n    # This helps in finer convergence control\n    adjusted_mu = 1.0 + (mu - 1.0) / (k + 1.0)\n\n    # Summable step size (independent of residuals)\n    t = tau(k, c, p)\n\n    # Direction logic ONLY (may depend on residuals)\n    if r_norm > adjusted_mu * max(s_norm, eps):\n        new_rho = rho * (1.0 + t)\n        mode = \"mul\"\n\n    elif s_norm > adjusted_mu * max(r_norm, eps):\n        new_rho = rho / (1.0 + t)\n        mode = \"div\"\n\n    else:\n        new_rho = rho\n        mode = \"keep\"\n\n    # Auxiliary scalar: purely tau_k (no residual dependence)\n    aux = t\n\n    return new_rho, aux, mode\n>>>>>>> REPLACE\n\nThese changes:\n1. Revert `tau` to the standard form used in top programs (which should satisfy the requirements better)\n2. Replace the complex ratio-based logic with the simpler, proven logic from successful programs\n3. Introduce an adaptive `mu` that decreases with iterations (similar to Program D2) for diversity while maintaining the core update pattern\n4. Ensure `aux` is set to `t` (independent of residuals) as required\n\nThis should improve the fitness score back towards 0.0769 while keeping some diversity through the adaptive mu adjustment. The adaptive mu approach was present in Program 2 and D2, which both scored 0.0769, so it's a good feature to retain."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}